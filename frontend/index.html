<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Моя Лента</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 0; background-color: #f0f2f5; color: #1c1e21; overflow-y: scroll; }
        .app-container { padding: 12px; }
        .feed-container { max-width: 600px; margin: 0 auto; }
        .post-card { background-color: #ffffff; border-radius: 8px; margin-bottom: 12px; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); border: 1px solid #ddd; overflow: hidden; }
        .post-content { padding: 16px; }
        .post-header { display: flex; align-items: center; margin-bottom: 12px; }
        .channel-title { font-weight: 600; font-size: 1.1em; }
        .post-date { color: #65676b; font-size: 0.9em; margin-left: auto; }
        .post-text { white-space: pre-wrap; line-height: 1.5; font-size: 1em; margin-bottom: 16px; }
        .comment-button { display: inline-block; padding: 8px 16px; background-color: #e7f3ff; color: #1877f2; text-decoration: none; border-radius: 6px; font-weight: 500; transition: background-color 0.2s; }
        .comment-button:hover { background-color: #dbeaff; }
        .status-message { text-align: center; padding: 40px; font-size: 1.2em; color: #65676b; }
        .post-media-visual { width: 100%; max-height: 70vh; object-fit: cover; display: block; }
        .post-media-audio { width: 100%; margin-top: 12px; }
        .post-card-with-media .post-content { padding-top: 12px; }
        
        /* --- СТИЛИ ДЛЯ PULL-TO-REFRESH --- */
        .pull-to-refresh-container {
            text-align: center;
            height: 0;
            transition: height 0.2s;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .pull-to-refresh-container.visible {
            height: 60px; /* Высота, на которую опускается индикатор */
        }
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        // --- Компоненты PostMedia и PostCard без изменений ---
        function PostMedia({ post }) {
            if (!post.media_url) return null;
            if (post.media_type === 'photo') return <img src={post.media_url} className="post-media-visual" alt="Изображение из поста" />;
            if (post.media_type === 'video') return <video controls className="post-media-visual"><source src={post.media_url} /></video>;
            if (post.media_type === 'audio') return <audio controls className="post-media-audio"><source src={post.media_url} /></audio>;
            return null;
        }
        function PostCard({ post }) {
            const formatDate = (dateString) => new Date(dateString).toLocaleString('ru-RU', { day: 'numeric', month: 'long', hour: '2-digit', minute: '2-digit' });
            const getPostUrl = (p) => p.channel.username ? `https://t.me/${p.channel.username}/${p.message_id}` : `https://t.me/c/${String(p.channel.id).substring(4)}/${p.message_id}`;
            const postUrl = getPostUrl(post);
            const isAudio = post.media_type === 'audio';
            return (
                <div className={`post-card ${post.media_url && !isAudio ? 'post-card-with-media' : ''}`}>
                    {!isAudio && <PostMedia post={post} />}
                    <div className="post-content">
                        <div className="post-header"><div className="channel-title">{post.channel.title}</div><div className="post-date">{formatDate(post.date)}</div></div>
                        {isAudio && <PostMedia post={post} />}
                        {post.text && <div className="post-text">{post.text}</div>}
                        <a href={postUrl} target="_blank" rel="noopener noreferrer" className="comment-button">Комментировать</a>
                    </div>
                </div>
            );
        }

        // --- Основной компонент приложения ---
        function App() {
            const [posts, setPosts] = useState([]);
            const [error, setError] = useState(null);
            const [userId, setUserId] = useState(null);
            const [page, setPage] = useState(1);
            const [hasMore, setHasMore] = useState(true);
            const [isFetching, setIsFetching] = useState(false);
            const [initialLoading, setInitialLoading] = useState(true);
            const loader = useRef(null);

            // --- НОВЫЕ СОСТОЯНИЯ ДЛЯ PULL-TO-REFRESH ---
            const [isRefreshing, setIsRefreshing] = useState(false);
            const touchStart = useRef(0);
            const touchEnd = useRef(0);
            const PULL_DISTANCE = 70; // Дистанция, на которую нужно потянуть для обновления

            const fetchPosts = useCallback(async (isRefresh = false) => {
                if (!userId || isFetching) return;
                
                const currentPage = isRefresh ? 1 : page;
                if (isRefresh) {
                    setIsRefreshing(true);
                } else {
                    setIsFetching(true);
                }

                try {
                    const response = await fetch(`https://telegram-feed-app-production-c1ed.up.railway.app/api/feed/${userId}?page=${currentPage}`);
                    if (!response.ok) throw new Error(`Ошибка: ${response.status}`);
                    
                    const newPosts = await response.json();
                    
                    if (isRefresh) {
                        setPosts(newPosts);
                    } else {
                        setPosts(prevPosts => [...prevPosts, ...newPosts]);
                    }
                    
                    setHasMore(newPosts.length > 0);
                    setPage(currentPage + 1);

                } catch (err) {
                    setError(err.message);
                } finally {
                    setIsFetching(false);
                    setInitialLoading(false);
                    setIsRefreshing(false);
                }
            }, [page, userId, isFetching]);
            
            // --- ОБРАБОТЧИКИ ЖЕСТА ---
            const handleTouchStart = (e) => {
                touchStart.current = e.targetTouches[0].clientY;
            };

            const handleTouchMove = (e) => {
                touchEnd.current = e.targetTouches[0].clientY;
            };

            const handleTouchEnd = () => {
                if (window.scrollY === 0 && touchStart.current < touchEnd.current - PULL_DISTANCE) {
                    // Пользователь потянул вниз в самом верху страницы
                    fetchPosts(true); // Вызываем обновление
                }
                touchStart.current = 0;
                touchEnd.current = 0;
            };

            // Эффект для инициализации
            useEffect(() => {
                const tg = window.Telegram.WebApp;
                const testUserId = 592766269; // ВАШ ID ДЛЯ ТЕСТОВ
                const currentUserId = tg.initDataUnsafe?.user?.id || testUserId;
                setUserId(currentUserId);
                
                tg.ready();
                document.body.style.backgroundColor = tg.themeParams.bg_color || '#f0f2f5';
                document.body.style.color = tg.themeParams.text_color || '#1c1e21';
            }, []);

            // Запускаем первую загрузку
            useEffect(() => {
                if (userId) {
                    fetchPosts();
                }
            }, [userId]);
            
            // Эффект для бесконечной прокрутки
            useEffect(() => {
                const observer = new IntersectionObserver(
                    entries => {
                        if (entries[0].isIntersecting && hasMore && !isFetching && !initialLoading) {
                            fetchPosts();
                        }
                    }, { threshold: 1 }
                );
                const currentLoader = loader.current;
                if (currentLoader) observer.observe(currentLoader);
                return () => { if (currentLoader) observer.unobserve(currentLoader); };
            }, [loader, fetchPosts, hasMore, isFetching, initialLoading]);

            if (initialLoading) return <div className="status-message"><div className="loader"></div></div>;
            if (error) return <div className="status-message">Ошибка: {error}</div>;
            
            return (
                <div 
                    className="app-container"
                    onTouchStart={handleTouchStart}
                    onTouchMove={handleTouchMove}
                    onTouchEnd={handleTouchEnd}
                >
                    <div className={`pull-to-refresh-container ${isRefreshing ? 'visible' : ''}`}>
                        {isRefreshing && <div className="loader"></div>}
                    </div>
                    <div className="feed-container">
                        {posts.length === 0 && !isFetching && (
                             <div className="status-message">Ваша лента пока пуста. Добавьте каналы через бота!</div>
                        )}
                        {posts.map(post => <PostCard key={`${post.message_id}-${post.channel.id}`} post={post} />)}
                        {isFetching && !isRefreshing && hasMore && (
                            <div className="loader-container">
                                <div className="loader"></div>
                            </div>
                        )}
                        <div ref={loader} />
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
