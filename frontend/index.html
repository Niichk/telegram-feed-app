<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>len.</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        /* ... твои старые стили ... */
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
            margin: 0; 
            padding: 12px; 
            background-color: #f0f2f5; 
            color: #1c1e21;
            overscroll-behavior-y: contain; /* Предотвращает "отскок" страницы в Safari/Chrome на мобильных */
        }
        /* ... */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- НОВЫЕ СТИЛИ ДЛЯ PULL-TO-REFRESH --- */
        .pull-to-refresh-loader {
            position: absolute;
            top: -50px; /* Изначально спрятан над экраном */
            left: 50%;
            transform: translateX(-50%);
            background-color: #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 10;
            transition: top 0.2s ease-out; /* Плавное появление */
        }
    </style>
</head>
<body>
    <div id="refresh-indicator" class="pull-to-refresh-loader">
        <div class="loader"></div>
    </div>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        // --- Компоненты PostMedia и PostCard без изменений ---
        // ... (твой код компонентов)

        function App() {
            const [posts, setPosts] = useState([]);
            const [error, setError] = useState(null);
            const [page, setPage] = useState(1);
            const [hasMore, setHasMore] = useState(true);
            const [isFetching, setIsFetching] = useState(false);
            const [initialLoading, setInitialLoading] = useState(true);
            const loader = useRef(null);

            // --- НОВЫЕ СОСТОЯНИЯ ДЛЯ PULL-TO-REFRESH ---
            const pullStartY = useRef(0);
            const pullDeltaY = useRef(0);
            const isPulling = useRef(false);

            const fetchPosts = useCallback(async (isRefresh = false) => {
                if (isFetching) return;
                
                const currentPage = isRefresh ? 1 : page;
                
                setIsFetching(true);

                // ОШИБОЧНЫЙ БЛОК IF УДАЛЕН ОТСЮДА

                try {
                    const response = await fetch(
                        `https://telegram-feed-app-production.up.railway.app/api/feed/?page=${currentPage}`,
                        { headers: { 'Authorization': `tma ${window.Telegram.WebApp.initData}` } }
                    );
                    
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => null);
                        throw new Error(errorData?.detail || `HTTP ошибка: ${response.status}`);
                    }
                    
                    const newPosts = await response.json();
                    
                    setPosts(prevPosts => isRefresh ? newPosts : [...prevPosts, ...newPosts]);
                    setHasMore(newPosts.length > 0);
                    setPage(currentPage + 1);

                } catch (err) {
                    setError(err.message);
                } finally {
                    // Этот блок правильный, он сработает только ПОСЛЕ завершения запроса
                    setIsFetching(false);
                    setInitialLoading(false);
                }
            }, [page, isFetching]);

            // --- НОВАЯ ФУНКЦИЯ ДЛЯ ОБНОВЛЕНИЯ ---
            const handleRefresh = useCallback(async () => {
                const tg = window.Telegram.WebApp;
                // Тактильный отклик для лучшего UX
                tg.HapticFeedback.impactOccurred('light'); 
                
                // Сбрасываем ошибку перед обновлением
                setError(null); 
                
                // Запускаем загрузку постов в режиме "обновление"
                await fetchPosts(true);
            }, [fetchPosts]);

            // --- НОВЫЙ ЭФФЕКТ ДЛЯ ОТСЛЕЖИВАНИЯ КАСАНИЙ ---
            useEffect(() => {
                const indicator = document.getElementById('refresh-indicator');

                const handleTouchStart = (e) => {
                    // Начинаем отслеживать, только если мы в самом верху страницы
                    if (window.scrollY === 0) {
                        pullStartY.current = e.touches[0].clientY;
                        isPulling.current = true;
                    }
                };

                const handleTouchMove = (e) => {
                    if (!isPulling.current) return;
                    
                    const delta = e.touches[0].clientY - pullStartY.current;
                    pullDeltaY.current = delta;

                    // Если тянем вниз
                    if (delta > 0) {
                        // Показываем индикатор и двигаем его вниз
                        indicator.style.top = `${Math.min(delta, 100) - 50}px`;
                    }
                };

                const handleTouchEnd = () => {
                    if (!isPulling.current) return;

                    // Если потянули достаточно далеко, запускаем обновление
                    if (pullDeltaY.current > 70) {
                        indicator.style.top = '20px'; // Оставляем индикатор видимым
                        handleRefresh().finally(() => {
                            indicator.style.top = '-50px'; // Прячем после завершения
                        });
                    } else {
                        // Если потянули недостаточно, просто прячем индикатор
                        indicator.style.top = '-50px';
                    }
                    
                    isPulling.current = false;
                    pullDeltaY.current = 0;
                };

                window.addEventListener('touchstart', handleTouchStart);
                window.addEventListener('touchmove', handleTouchMove);
                window.addEventListener('touchend', handleTouchEnd);

                return () => {
                    window.removeEventListener('touchstart', handleTouchStart);
                    window.removeEventListener('touchmove', handleTouchMove);
                    window.removeEventListener('touchend', handleTouchEnd);
                };
            }, [handleRefresh]);

            // Эффект для инициализации и первой загрузки (без изменений)
            useEffect(() => {
                const tg = window.Telegram.WebApp;
                const currentUserId = tg.initDataUnsafe?.user?.id;
                
                if (currentUserId) {
                    fetchPosts();
                } else {
                    setError("Не удалось определить пользователя Telegram.");
                    setInitialLoading(false);
                }
                
                tg.ready();
                document.body.style.backgroundColor = tg.themeParams.bg_color || '#f0f2f5';
                document.body.style.color = tg.themeParams.text_color || '#1c1e21';
            }, []); // Запускается один раз

            // Эффект для бесконечной прокрутки (без изменений)
            useEffect(() => {
                const handleObserver = (entities) => {
                    const target = entities[0];
                    if (target.isIntersecting && hasMore && !isFetching) {
                        fetchPosts();
                    }
                };
                
                const observer = new IntersectionObserver(handleObserver, { threshold: 1 });
                const currentLoader = loader.current;
                if (currentLoader) observer.observe(currentLoader);
                return () => {
                    if (currentLoader) observer.unobserve(currentLoader);
                };
            }, [loader, fetchPosts, hasMore, isFetching]);
            
            // Логика отображения (без изменений)
            if (initialLoading) return <div className="status-message"><div className="loader"></div></div>;
            if (error) return <div className="status-message">Ошибка: {error}</div>;
            if (posts.length === 0 && !hasMore) return <div className="status-message">Ваша лента пока пуста. Добавьте каналы через бота!</div>;

            return (
                <div className="feed-container">
                    {posts.map(post => <PostCard key={`${post.id}-${post.message_id}`} post={post} />)}
                    {isFetching && !initialLoading && (
                        <div className="loader-container">
                            <div className="loader"></div>
                        </div>
                    )}
                    <div ref={loader} />
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>